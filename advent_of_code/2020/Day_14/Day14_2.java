import java.util.*;

public class Day14_2 {
	// See readMask for more information about bitmaskLength, andMask and orMask.
	private static int bitmaskLength = 36;
	private static long andMask;
	private static long orMask;

	public static void main(String[] args) {
		HashMap<Long, Long> memory = new HashMap<>();
		String mask = "";

		Scanner in = new Scanner(System.in);
		while(in.hasNext()) {
			Scanner line = new Scanner(in.nextLine());
			String instruction = line.next();
			if (instruction.equals("mask")) {
				line.next(); // eat '='
				mask = line.next();
				readMask(mask);
			}
			else if (instruction.startsWith("mem")) {
				String s = instruction.substring("mem[".length());
				s = s.substring(0, s.length() - 1); // remove ']'
				long memoryPosition = Long.valueOf(s).longValue();
				line.next(); // eat '='
				long value = line.nextLong();

				memoryPosition = applyMask(memoryPosition);
				Floating v = new Floating(mask, memoryPosition);
				while (v.hasNext()) {
					long position = v.nextValue();
					memory.put(Long.valueOf(position), Long.valueOf(value));
				}
			}
			line.close();
		}
		in.close();


		System.out.println("Sum: " + sum(memory.values()));
	}

	private static long sum(Collection<Long> values) {
		long sum = 0;
		for (Long v: values) {
			sum += v.longValue();
		}
		return sum;
	}

	private static long applyMask(long value) {
		// Could just be (value | orMask) because the andMask is just 11111..111
		return (value & andMask) | orMask;
	}

	/**
	 * Updates the mask.
	 * 
	 * @param mask
	 */
	private static void readMask(String mask) {
		// The original mask information is split in two masks, one to force 0s
		// and the other to force 1s.
		// Because this time 0s mean that the value is unchanged, the and mask
		// is not necessary.

		// The andMask holds the bits to be set to 0 and is applied with a
		// bitwise AND to the value.
		andMask = (1L << bitmaskLength) - 1; // Holds the bits to be set to 0.
		// The orMask holds the bits to be set to 1 and is applied with a
		// bitwise OR to the value. 
		orMask = 0;

		char[] maskArray = mask.toCharArray();
		for (int exponent = 0; exponent < maskArray.length; exponent++) {
			int i = maskArray.length - 1 - exponent;
			if (maskArray[i] == '1') {
				orMask = orMask | (1L << exponent);
			}
			// else if (maskArray[i] == '0') {
			// 	andMask = ~(~andMask | (1L << i));
			// }
		}
	}

	/**
	 * Transforms mask value to binary String representation.
	 * 
	 * @param mask bitmask to print in binary format
	 * @param length number of bits of the bitmask to put in the string
	 * @return
	 */
	private static String binaryToString(long mask, int length) {
		StringBuilder b = new StringBuilder();
		String s = Long.toBinaryString(mask);
		if (s.length() > length) {
			s = s.substring(s.length() - length);
			b.append(s);
		}
		else {
			b.append(s);
			b.reverse();
			while(b.length() < length) {
				b.append('0');
			}
			b.reverse();
		}
		return b.toString();
	}

	private static class Floating {
		char[] maskArray;
		long value;
		int nX; // Number of X in the mask
		// To generate all possible "floating" values, the permutations are
		// generated by counting from 0 to ((1 << nX) - 1), and the binary
		// representations of the counter are applied in the X positions
		// indicated of the mask.
		long xCount;

		Floating(String mask, long value) {
			this.maskArray = mask.toCharArray();
			this.value = value;
			this.nX = 0;
			for (int i = 0; i < mask.length(); i++) {
				if (this.maskArray[i] == 'X') {
					nX++;
				}
			}
			this.xCount = 0L;
		}

		boolean hasNext() {
			return xCount < (1 << nX);
		}

		long nextValue() {
			// apply mask with current xCount
			char[] countMask = binaryToString(xCount, nX).toCharArray();
			long val = this.value;
			int posXMask = maskArray.length - 1;
			int posCountMask = countMask.length - 1;
			// Find the X's in the the mask and apply the respective bit
			// of the counter to the value.
			while(posXMask >= 0) {
				if (maskArray[posXMask] == 'X') {
					int valueExp = (maskArray.length - 1) - posXMask;
					if (countMask[posCountMask] == '0') {
						val = val & (~(1L << valueExp));
					}
					else {
						val = val | (1L << valueExp);
					}
					posCountMask--;
				}
				posXMask--;
			}
			// Increment xCount for the next call.
			xCount++;
			return val;
		}
	}

}
